A[32] B[32] Shift[5] CarryIn[1] Codop[4] S[32] Flags[4]

# -------------------------------------------------------------------------
# 1. AND: 1 & 1 = 1. Flags: 0
00000000000000000000000000000001 00000000000000000000000000000001 00000 0 0000 00000000000000000000000000000001 0000

# 2. AND (Test Zero): 0F & F0 = 0. Flags: Z=1 (0100)
00000000000000000000000000001111 00000000000000000000000011110000 00000 0 0000 00000000000000000000000000000000 0100

# 3. EOR: 0F ^ F0 = FF. Flags: 0
00000000000000000000000000001111 00000000000000000000000011110000 00000 0 0001 00000000000000000000000011111111 0000

# -------------------------------------------------------------------------
# 4. LSL: 1 << 1 = 2. Flags: 0
00000000000000000000000000000000 00000000000000000000000000000001 00001 0 0010 00000000000000000000000000000010 0000

# 21. LSL Special: 0x80000000 << 1. Le bit 1 sort (C=1), reste 0 (Z=1). Flags: 0110
00000000000000000000000000000000 10000000000000000000000000000000 00001 0 0010 00000000000000000000000000000000 0110

# 5. LSR: F0...00 >> 4 = 0F...00. Flags: 0
00000000000000000000000000000000 11110000000000000000000000000000 00100 0 0011 00001111000000000000000000000000 0000

# 22. LSR Special: 1 >> 1. Le bit 1 sort (C=1), reste 0 (Z=1). Flags: 0110
00000000000000000000000000000000 00000000000000000000000000000001 00001 0 0011 00000000000000000000000000000000 0110

# 6. ASR: 80...00 (-Huge) >> 4. Garde le signe. Flags: N=1 (1000)
00000000000000000000000000000000 10000000000000000000000000000000 00100 0 0100 11111000000000000000000000000000 1000

# 23. ASR Special: -1 >> 1. Reste -1. C=1 (bit sortant). Flags: N=1, C=1 -> 1010
00000000000000000000000000000000 11111111111111111111111111111111 00001 0 0100 11111111111111111111111111111111 1010

# -------------------------------------------------------------------------
# 7. ADC: 1 + 1 + 1(Cin) = 3. Flags: 0
00000000000000000000000000000001 00000000000000000000000000000001 00000 1 0101 00000000000000000000000000000011 0000

# 8. SBC: B(3) - A(5) + Cin(1) - 1 = -2.
# Spec: B - A - !Cin. Si Cin=1, on soustrait 0. 3 - 5 = -2.
# Flags: N=1. Emprunt necessaire (3<5), donc C=0. Code: 1000
00000000000000000000000000000101 00000000000000000000000000000011 00000 1 0110 11111111111111111111111111111110 1000 

# -------------------------------------------------------------------------
# 9. ROR: ...01 rotated right 1 -> 1...00. Flags: N=1, C=1 (Bit 1 sortant). Code: 1010
00000000000000000000000000000000 10000000000000000000000000000001 00001 0 0111 11000000000000000000000000000000 1010

# -------------------------------------------------------------------------
# 10. TST (AND): 0F & F0 = 0.
# SPEC: S = B (F0). Flags: Z=1 (0100).
# resultat d'operation 00000000000000000000000000000000
00000000000000000000000000001111 00000000000000000000000011110000 00000 0 1000 00000000000000000000000011110000 0100

# 18. TST (AND): -1 & -1 = -1. 
# SPEC: S = B (-1). Flags: N=1 (1000).
# resultat d'operation 11111111111111111111111111111111
11111111111111111111111111111111 11111111111111111111111111111111 00000 0 1000 11111111111111111111111111111111 1000

# 19. TST (AND): 1 & 3 = 1. Resultat non-nul (Z=0) et positif (N=0).
# SPEC: S = B (3). Flags: 0000.
# resultat d'operation 00000000000000000000000000000001
00000000000000000000000000000001 00000000000000000000000000000011 00000 0 1000 00000000000000000000000000000011 0000

# -------------------------------------------------------------------------
# 11. RSB: 0 - A(1) = -1. Flags: N=1, C=0 (Emprunt) -> 1000
00000000000000000000000000000001 00000000000000000000000000000101 00000 0 1001 11111111111111111111111111111111 1000

# 20. RSB Overflow: 0 - (MinNeg). Overflow. 
# Flags: N=1, V=1, C=0 (Emprunt). Code: 1001
10000000000000000000000000000000 00000000000000000000000000000000 00000 0 1001 10000000000000000000000000000000 1001

# -------------------------------------------------------------------------
# 12. CMP: B(5) - A(10) = -5.
# SPEC: S = B (5). Flags: N=1, C=0 (Emprunt). Code: 1000
# resultat d'operation 11111111111111111111111111111011
00000000000000000000000000001010 00000000000000000000000000000101 00000 0 1010 00000000000000000000000000000101 1000

# 24. CMP Overflow: B(MaxPos) - A(-1) = Overflow Negatif.
# SPEC: S = B (MaxPos). Flags: N=1, V=1, C=0. Code: 1001
# resultat d'operation 11111111111111111111111111111011
11111111111111111111111111111111 01111111111111111111111111111111 00000 0 1010 01111111111111111111111111111111 1001

# 13. CMN: A(Max) + B(1) = Overflow Negatif.
# SPEC: S = B (1). Flags: N=1, V=1. Code: 1001
# resultat d'operation 10000000000000000000000000000000
01111111111111111111111111111111 00000000000000000000000000000001 00000 0 1011 00000000000000000000000000000001 1001

# -------------------------------------------------------------------------
# 14. ORR: F | F0 = FF. Flags: 0
00000000000000000000000000001111 00000000000000000000000011110000 00000 0 1100 00000000000000000000000011111111 0000

# 15. MUL: 16 * 4 = 64. Flags: 0
00000000000000000000000000010000 00000000000000000000000000000100 00000 0 1101 00000000000000000000000001000000 0000

# 25. MUL: 16 * 0 = 0. Flags: Z=1
00000000000000000000000000010000 00000000000000000000000000000000 00000 0 1101 00000000000000000000000000000000 0100

# 16. BIC: B(F0F0..) AND NOT A(FFFF.. / -1). Result = 0. Flags: Z=1 (0100)
11111111111111111111111111111111 00001111000011110000111100001111 00000 0 1110 00000000000000000000000000000000 0100

# 17. MVN: NOT A(0) = -1. Flags: N=1 (1000)
00000000000000000000000000000000 11111111111111111111111111111111 00000 0 1111 11111111111111111111111111111111 1000